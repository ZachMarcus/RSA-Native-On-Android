
#define __CL_ENABLE_EXCEPTIONS
#define CL_USE_DEPRECATED_OPENCL_1_1_APIS

#include <jni.h>

#include "crypto.h"

void cMain(int numberOfTimes, int c_d, int c_n, int c_key);
void clMain(int numberOfTimes);
void GMPmain(int numberOfTimes);

extern "C" {

    JNIEXPORT jstring JNICALL
         Java_com_sidechannel_rsa_openssl_MainActivity_RSAFromJNI( JNIEnv* env,
                                                                   jobject thiz,
																   jboolean rsaChoice,
																   jboolean rsaOpenCLChoice,
																   jboolean runRSAGMPChoice,
																   jint numberOfTimes) {
         #if defined(__arm__)
             #if defined(__ARM_ARCH_7A__)
               #if defined(__ARM_NEON__)
                 #if defined(__ARM_PCS_VFP)
                   #define ABI "armeabi-v7a/NEON (hard-float)"
                 #else
                   #define ABI "armeabi-v7a/NEON"
                 #endif
               #else
                 #if defined(__ARM_PCS_VFP)
                   #define ABI "armeabi-v7a (hard-float)"
                 #else
                   #define ABI "armeabi-v7a"
                 #endif
               #endif
             #else
              #define ABI "armeabi"
             #endif
         #elif defined(__i386__)
             #define ABI "x86"
         #elif defined(__x86_64__)
             #define ABI "x86_64"
         #elif defined(__mips64)  // mips64el-* toolchain defines __mips__ too
             #define ABI "mips64"
         #elif defined(__mips__)
             #define ABI "mips"
         #elif defined(__aarch64__)
         #define ABI "arm64-v8a"
         #else
             #define ABI "unknown"
         #endif

    	if((rsaChoice && rsaOpenCLChoice) || (rsaChoice && runRSAGMPChoice) || (rsaOpenCLChoice && runRSAGMPChoice)) {
    		return env->NewStringUTF("You can only choose one");
    	}
    	else if(!(rsaChoice || rsaOpenCLChoice || runRSAGMPChoice)) {
    		return env->NewStringUTF("You have to choose one");
    	}
    	else if(rsaChoice) {
            cMain(numberOfTimes, 83, 59, 954);
    		return env->NewStringUTF("You ran RSA, compiled with " ABI ".");
    	}
    	else if(rsaOpenCLChoice) {
    		clMain(numberOfTimes);
    		return env->NewStringUTF("You ran RSA with OpenCL, compiled with " ABI ".");
    	}
    	else if(runRSAGMPChoice) {
    		GMPmain(numberOfTimes);
    		return env->NewStringUTF("You ran RSAGMP!");
    	}
    	else {
    		return env->NewStringUTF("Something is broken somewhere");
    	}
    }
}


void GMPmain(int numberOfTimes) {
	uint64_t diff;
	struct timespec start, end;

	/*std::string eString = "10011011001101110101111001101011011001010000000100000101011011011111100001110100001111011110010011100000011010111101110000001000001001100011110010000000101100001000100101101011001100001101001000000111001110110110111100010110001101011100011010110101010101001001010101110000100011000010110001001111000100111001010101110101010011010011010101000010000101010000000111010010110011010011101001101001111010110010001010111101001010000010101101110011001100011110111111011000101100000000010101000100101000010001101000101001100111110000010001000000001001101110011011010010100010101101100111010110100010000100100000011000011101100001110001011100011101010110000010000101110101111110001101000110000111100000101011101010110001010001001100010001011001000001010001101100111110101011000001110111001001001010001000011001110101101110001010111101001010000000100001011111101101011101001100101101110111111011001000110010001101011000111011101001101010000111001100000111100110110000011111001001101001001110110001001101010101010011001011111000011011010101111101101001111000001111011011000000101101110000111010100001011000011101000001111000010111000010111101010100000100000011011100101001000100011111010100110000010110011001001010110010101111110000000110001101010110011000010100011000111010100010101101110011010111010011110101111111110101010011111100110111011110001010011010110110001001011101101010001111001011100111110111001100010110001011100111101011011011010000100111011000100111000000000101011010000110101101001110111011111110010110110011110111110100110101000011110011111110011111110000100000001101001111001100111011111100010111011111000011111001010101001101011111010001111010000110100111001010010100101001011000011010011001001011001111000111111010110110101001110011011111001111001111111010000011001001100101111111000010000001111110011100010010101101110110011100001010011001101110111101111011110111001110100101110111010100001111110000101110011101000101110011111000000000000010101000100110110000101010111000010000010000101101111101111001111111101001110111101011110100101000100010000011111000100101101010110101011000100101001001100011001110100011101101000001011111000101011010101111110011000111100000011001111101101101100110010111100100100100100110010011001001010110111111011111110110101111100101111001111011101000011011010100110100110001111000110011010010011011001010100010000010110000001101011111110110011001000001110011010110101001010000100111001101111110110110010010111110100000111000111101001111011000011111110011001111011011101010001000001111110011101011001110111101011010000110100010101111010100110011100010101010101010110001111010110100011011110101110101011000110001011110111001000000010011110100010001001010011001111011111000000001001000100100100110000011001111110001010001101110100000101100011001001110000111010010110101101000101110101011110110001000010011011010010011101001010110111000011011100000110100011011101000011010001110111100010111101001000001011001111101101110001100100010000100101011011101111101001100101011001010111011001010011111001101010111110101000010001110111101110110011000011011100011100100000111010010111001000001000011100011011011101000101011001000010110110010111001001101110011010111111001010100001110000001110101001000101000101000101010001010001100000001100000111001110110010001010111010001011111010101010110000011011110001100101011001101011000001110001011011001011101000010101111111100110101110001000111110001011000000010000110000101100110100101000111111101100101011100010101100011101101100000011100001111011100011101010101001110010100100011101111100100011011001010110000000100010001110100100110000101000111010101001100001010100010010111100001011001011111110001001101001000110101111000100100010000010100011010011111100011011000010111011101010110001110011000011011010011101100100001010110001010110101111011000011110010011011111000111101110111000001011001110011010001000000100100010100101111110110100110111100011000010111100111011000110011011110011001100101101001001100111101100110000101101100001000100001000111101101011011000111010010111110000011001111110111001111011111100100000101100001";
	uint8_t eStringArray[eString.length()];
	for(int i = 0; i < eString.length(); i++) {
		eStringArray[i] = eString[i] - '0';
	}
	mpz_t eStringProper;
	mpz_init(eStringProper);
	mpz_import(eStringProper, sizeof(eStringArray), 1, sizeof(eStringArray[0]), 0, 0, eStringArray);*/

	/*std::string nString = "1010111101111110110011000000111001011100001010101000001111110110001010110001010001101110101100110111000111110111101011100110011001110000001100110101010101000010111010010011010110100000011010011111011000110011101001011111101100001010001001001111100010100101110100111001110000101000011110100001011001011101011001110011101000100110101010100011000101000011011000001101001111000111000010000011011000000011001000010011101100110110010010100110110010110100101100111110001101100001010110010101101110110010100111011111001010000010000111101000111100001001111110100001001000001111111010110011101100010001001101111110101010100110110000010001101000101011110101011000001001101110010011111111001010111000100010111000011111011110110001110011001001010011101110100101010001010101100100000100000010001010000011000111011100101110000111000111010111011000011010101011110011010111110100101000001000100100001101110100010010100001110000011001000001111101000011111100011010101110101101110010010111011000000100001100000111101001000000000000000111010110101110110010111111100101000000100100100101001110000001110100011111000111100011000001010110011011110010111101100111000100101110100000011110110101000101100111111111001010100101110100111111010111001111101101101110010001011111011100111110110010100100100010100010100010100110100101101010010001100110011010000010111110010111001011110111101110010111110101000000111010000000001001001111101110000000100001101001011010011100000100011010001100100011110111100111011100100111110111001100000010111111010101111110001110101100010101110101101001111100011011110001000101110101001110111100010100001101010111001000110010111000000000111111110010101110000001110001110100100110100110100011011001001000011000110100010011001110010110011101100001011010110001000010100100001111000000111010001100111001011111110100110111010100100011001011100101100010100011110001011111111100101011111000110111100001011110110001101100111111101110110011101110110011010001110100000000001110010111000000111000011101001111001000000001111011110001010100011010111001101011100100010111000010110000000000111111001100010000010101000100010000101001011001101111101110101100110001111011101001000011110101110111001100001101000101000001010100001100111101111110100001000111001101100001010001001100111000110001011011101001100111001100100101000111010101000001110110101111110011101010101101111111100010010101001111010010101111000100001001000001001101011111111001001101101010010110111111101000011100111010101011100000110100011011010000000001010001000001111111101101011101010110011001011101110001110101001111001010010011001110001011000111001010100100010000111111001100000011110000100110110000101101101001100001011011001000011001010001010110001011011000011100001101100011101100111001100111010000000010011000001011001100111100011010110000001100010001110101110000001110000101001001111010001111101011001111110001111010100111000000101101100101111100110011111010111010001000001111110010000110100011000100101101101011100001011011111010100101011001100101101001011011010011101100111111011000000011011110000001100110100101000001101011011000011000000100000011110011101100011101110100101010010111101110100111100111011001101001000000100011100000010100010001001011100110100110001000101110001110011011001000101101100000000110110001111111001011010110110000011000101111101111100100111010111011000110000101110001101100111011000011100000010011010000100000100000000010001111111010000000111001000010111100000110011000001000011001001100100100001010001001101100010101011110111100101111001000011010000010101111010111011010000010100110011110111001101001111010011100011110010110000111100110001111010101010000101011101111011100111000101001101101101011011100111000010000011101101010101111001000011111111101100001111100000001110011010001101010100011001001011100011100110101001110001110001001011101010001001111000100100110110110010011011110011110101000111110111000110000111100100101101110101100001010010101101110010110010111001011111011100010010011100101011000010111101111011000111010001001010111000010010101001110110001111100000001011100011110001010001011000101101101";
	uint8_t nStringArray[nString.length()];
	for(int i = 0; i < nString.length(); i++) {
		nStringArray[i] = nString[i] - '0';
	}
	mpz_t nStringProper;
	mpz_init(nStringProper);
	mpz_import(nStringProper, sizeof(nStringArray), 1, sizeof(nStringArray[0]), 0, 0, nStringArray);*/


	//const std::string eString = "29";
	//const std::string nString = "16637";
	//mpz_class e(eString, 10);
	//mpz_class n(nString, 10);

	//mpz_class e(eStringProper);
	//mpz_class n(nStringProper);


	//std::string eString = "10011011001101110101111001101011011001010000000100000101011011011111100001110100001111011110010011100000011010111101110000001000001001100011110010000000101100001000100101101011001100001101001000000111001110110110111100010110001101011100011010110101010101001001010101110000100011000010110001001111000100111001010101110101010011010011010101000010000101010000000111010010110011010011101001101001111010110010001010111101001010000010101101110011001100011110111111011000101100000000010101000100101000010001101000101001100111110000010001000000001001101110011011010010100010101101100111010110100010000100100000011000011101100001110001011100011101010110000010000101110101111110001101000110000111100000101011101010110001010001001100010001011001000001010001101100111110101011000001110111001001001010001000011001110101101110001010111101001010000000100001011111101101011101001100101101110111111011001000110010001101011000111011101001101010000111001100000111100110110000011111001001101001001110110001001101010101010011001011111000011011010101111101101001111000001111011011000000101101110000111010100001011000011101000001111000010111000010111101010100000100000011011100101001000100011111010100110000010110011001001010110010101111110000000110001101010110011000010100011000111010100010101101110011010111010011110101111111110101010011111100110111011110001010011010110110001001011101101010001111001011100111110111001100010110001011100111101011011011010000100111011000100111000000000101011010000110101101001110111011111110010110110011110111110100110101000011110011111110011111110000100000001101001111001100111011111100010111011111000011111001010101001101011111010001111010000110100111001010010100101001011000011010011001001011001111000111111010110110101001110011011111001111001111111010000011001001100101111111000010000001111110011100010010101101110110011100001010011001101110111101111011110111001110100101110111010100001111110000101110011101000101110011111000000000000010101000100110110000101010111000010000010000101101111101111001111111101001110111101011110100101000100010000011111000100101101010110101011000100101001001100011001110100011101101000001011111000101011010101111110011000111100000011001111101101101100110010111100100100100100110010011001001010110111111011111110110101111100101111001111011101000011011010100110100110001111000110011010010011011001010100010000010110000001101011111110110011001000001110011010110101001010000100111001101111110110110010010111110100000111000111101001111011000011111110011001111011011101010001000001111110011101011001110111101011010000110100010101111010100110011100010101010101010110001111010110100011011110101110101011000110001011110111001000000010011110100010001001010011001111011111000000001001000100100100110000011001111110001010001101110100000101100011001001110000111010010110101101000101110101011110110001000010011011010010011101001010110111000011011100000110100011011101000011010001110111100010111101001000001011001111101101110001100100010000100101011011101111101001100101011001010111011001010011111001101010111110101000010001110111101110110011000011011100011100100000111010010111001000001000011100011011011101000101011001000010110110010111001001101110011010111111001010100001110000001110101001000101000101000101010001010001100000001100000111001110110010001010111010001011111010101010110000011011110001100101011001101011000001110001011011001011101000010101111111100110101110001000111110001011000000010000110000101100110100101000111111101100101011100010101100011101101100000011100001111011100011101010101001110010100100011101111100100011011001010110000000100010001110100100110000101000111010101001100001010100010010111100001011001011111110001001101001000110101111000100100010000010100011010011111100011011000010111011101010110001110011000011011010011101100100001010110001010110101111011000011110010011011111000111101110111000001011001110011010001000000100100010100101111110110100110111100011000010111100111011000110011011110011001100101101001001100111101100110000101101100001000100001000111101101011011000111010010111110000011001111110111001111011111100100000101100001";
	//std::string nString = "1010111101111110110011000000111001011100001010101000001111110110001010110001010001101110101100110111000111110111101011100110011001110000001100110101010101000010111010010011010110100000011010011111011000110011101001011111101100001010001001001111100010100101110100111001110000101000011110100001011001011101011001110011101000100110101010100011000101000011011000001101001111000111000010000011011000000011001000010011101100110110010010100110110010110100101100111110001101100001010110010101101110110010100111011111001010000010000111101000111100001001111110100001001000001111111010110011101100010001001101111110101010100110110000010001101000101011110101011000001001101110010011111111001010111000100010111000011111011110110001110011001001010011101110100101010001010101100100000100000010001010000011000111011100101110000111000111010111011000011010101011110011010111110100101000001000100100001101110100010010100001110000011001000001111101000011111100011010101110101101110010010111011000000100001100000111101001000000000000000111010110101110110010111111100101000000100100100101001110000001110100011111000111100011000001010110011011110010111101100111000100101110100000011110110101000101100111111111001010100101110100111111010111001111101101101110010001011111011100111110110010100100100010100010100010100110100101101010010001100110011010000010111110010111001011110111101110010111110101000000111010000000001001001111101110000000100001101001011010011100000100011010001100100011110111100111011100100111110111001100000010111111010101111110001110101100010101110101101001111100011011110001000101110101001110111100010100001101010111001000110010111000000000111111110010101110000001110001110100100110100110100011011001001000011000110100010011001110010110011101100001011010110001000010100100001111000000111010001100111001011111110100110111010100100011001011100101100010100011110001011111111100101011111000110111100001011110110001101100111111101110110011101110110011010001110100000000001110010111000000111000011101001111001000000001111011110001010100011010111001101011100100010111000010110000000000111111001100010000010101000100010000101001011001101111101110101100110001111011101001000011110101110111001100001101000101000001010100001100111101111110100001000111001101100001010001001100111000110001011011101001100111001100100101000111010101000001110110101111110011101010101101111111100010010101001111010010101111000100001001000001001101011111111001001101101010010110111111101000011100111010101011100000110100011011010000000001010001000001111111101101011101010110011001011101110001110101001111001010010011001110001011000111001010100100010000111111001100000011110000100110110000101101101001100001011011001000011001010001010110001011011000011100001101100011101100111001100111010000000010011000001011001100111100011010110000001100010001110101110000001110000101001001111010001111101011001111110001111010100111000000101101100101111100110011111010111010001000001111110010000110100011000100101101101011100001011011111010100101011001100101101001011011010011101100111111011000000011011110000001100110100101000001101011011000011000000100000011110011101100011101110100101010010111101110100111100111011001101001000000100011100000010100010001001011100110100110001000101110001110011011001000101101100000000110110001111111001011010110110000011000101111101111100100111010111011000110000101110001101100111011000011100000010011010000100000100000000010001111111010000000111001000010111100000110011000001000011001001100100100001010001001101100010101011110111100101111001000011010000010101111010111011010000010100110011110111001101001111010011100011110010110000111100110001111010101010000101011101111011100111000101001101101101011011100111000010000011101101010101111001000011111111101100001111100000001110011010001101010100011001001011100011100110101001110001110001001011101010001001111000100100110110110010011011110011110101000111110111000110000111100100101101110101100001010010101101110010110010111001011111011100010010011100101011000010111101111011000111010001001010111000010010101001110110001111100000001011100011110001010001011000101101101";
	//mpz_class e(eString, 2);
	//mpz_class n(nString, 2);
	mpz_class e("5592256007473496758", 10);
	mpz_class n("6322884582875415035", 10);



	char *dataString = new char[64];
	static const char numChars[] = "0123456789";
	std::string dataStringProper;

	FILE *file = fopen("/sdcard/RSA/GMPMainOutput.txt", "w");
	fprintf(file, "Running RSA with GMP on C\n");
	gmp_fprintf(file, "e = %Zd\n", e.get_mpz_t());
	gmp_fprintf(file, "n = %Zd\n", n.get_mpz_t());
	fprintf(file, "The data should go time in nanoseconds, a tab, then the message to be encrypted.\n");
	fclose(file);

	for(int timesCompleted = 0; timesCompleted < numberOfTimes; timesCompleted++) {
		for (int i = 0; i < 64; i++) {
					dataString[i] = numChars[rand() % (sizeof(numChars) - 1)];
		}
		dataStringProper = dataString;
		mpz_class data(dataStringProper, 10);
		char * cstrDataStringProper = new char [dataStringProper.length() + 1];
		std::strcpy(cstrDataStringProper, dataStringProper.c_str());

		clock_gettime(CLOCK_MONOTONIC, &start);
		GMPmod(data, e, n);
		clock_gettime(CLOCK_MONOTONIC, &end);
		diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;

		file = fopen("/sdcard/RSA/GMPMainOutput.txt", "a");
		fprintf(file, "%llu\t", (long long unsigned int) diff);
		fprintf(file, "%s\n", cstrDataStringProper);
		fclose(file);

	}

	return;
}

void GMPmod(mpz_class base, mpz_class exponent, mpz_class den) {
	mpz_class a, zbase, zden, ret;
	mpf_class size;
	zbase = base;
	zden = den; // convert to int
	a = (zbase%zden);
	a = a * a;
	size = exponent/2.0;
	if(exponent==0) {
		ret = zbase % zden;
	}
	else {
		while(1) {
			if(size>0.5f) {
				ret = (ret * a)%zden;
				size = size - 1.0f;
	        }
	        else if (size == 0.5f) {
	        	ret = zbase % zden;
	        	ret = ret * ret;
	        	ret = ret % zden;
	        	break;
	        }
	        else break;
	   }
	}
}


void cMod(int c_base, int c_exponent, int c_den)
{
	unsigned int c_a = (c_base % c_den) * (c_base % c_den);
	unsigned long int c_ret = 1;
	float c_size = (float)c_exponent / 2;

	if(c_exponent == 0) {
		c_ret = c_base % c_den;
	}
	else {

		while(1) {
			if(c_size>0.5f) {
				c_ret=(c_ret*c_a)%c_den;
				c_size=c_size-1.0f;
			}
			else if(c_size==0.5f) {
				c_ret=(c_ret*(c_base%c_den))%c_den;
				break;
			}
			else break;
		}
	}

}

void cMain(int numberOfTimes, int c_d, int c_n, int c_key) {
	uint64_t c_diff;
	struct timespec c_start, c_end;
	int completedTimes;
	FILE *file = fopen("sdcard/RSA/cMainOutput.txt", "w");
	fprintf(file, "Running RSA with C\n");
	//fclose(file);
	for(completedTimes = 0; completedTimes < numberOfTimes; completedTimes++) {
	    clock_gettime(CLOCK_MONOTONIC, &c_start);
	    cMod(c_d, c_n, c_key);
	    clock_gettime(CLOCK_MONOTONIC, &c_end);
	    c_diff = BILLION * (c_end.tv_sec - c_start.tv_sec) + c_end.tv_nsec - c_start.tv_nsec;
	    fprintf(file, "Time taken: %llu\n", (long long unsigned int) c_diff);
	}
	fclose(file);
	//printf("%llu", (long long unsigned int) c_diff);
    //return (long long unsigned int) c_diff;

}
/*
void cMain(int c_argc, char *c_argv[]) {
	int c_e = strtol(c_argv[1],NULL,0);
	int c_n = strtol(c_argv[2],NULL,0);
	int c_data = strtol(c_argv[3],NULL,2);

	uint64_t c_diff;
	struct timespec c_start, c_end;

	clock_gettime(CLOCK_MONOTONIC, &c_start);
	cMod(c_data, c_e, c_n);
	clock_gettime(CLOCK_MONOTONIC, &c_end);

	c_diff = BILLION * (c_end.tv_sec - c_start.tv_sec) + c_end.tv_nsec - c_start.tv_nsec;
	//printf("%llu", (long long unsigned int) c_diff);

}*/




// DECLARE GLOBALLY
int length =512;
int * buf;
int *dev_key,*dev_den;
//DECLARATION FOR e,d and n

long int p,q,n,t,flag,e[100],d[100],temp[100],j,m[100],en[100],i;
char msg[100];


//Continually increments k by t, until k is divisible by x.
//Returns the result of this division.
long int cd(long int x) {
    long int k=1;
    while(1) {
        k=k+t;
        if(k%x==0) {
            return(k/x);
        }
    }
}

//determines if the given number is prime.
//Returns 0 if not, 1 if so.
int prime(long int pr) {
    j=sqrt((double)pr);
    for(int i=2;i<=j;i++) {
        if(pr%i==0) {
            return 0;
        }
    }
    return 1;
}



void ce() {
    int k = 0;
    for(i=2;i<t;i++) {
        if(t % i == 0) {
            //nothing
        }
        else {
            flag=prime(i);
            if(flag==1&&i!=p&&i!=q) {
                e[k]=i;
                flag= cd(e[k]);

                if(flag>0) {
                    d[k]=flag;
                    k++;
                }
                if(k==99) {
                    break;
                }
            }
        }
    }
}


//Implementation of GetTickCount() for Linux systems.
//This code was originally written in Windows and this function is usually available in the
//windows.h include file
#include <sys/time.h>
long GetTickCount() {
	struct timeval tv;
	if (gettimeofday(&tv, NULL) != 0) {
		return 0;
	}
	return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
}

//MAIN STARTS

void clMain(int numberOfTimes) {

    //declaring variables to be used for timing, usage of OpenCL, etc.
    char build_c[4096];

    uint64_t diff;
    struct timespec start, end;

    cl_int error;
    cl_platform_id platform;
    cl_device_id device;
    cl_uint platforms, devices;
    size_t srcsize,worksize=length*sizeof(int);
    int i;
    int key=5;
    int den=7;
    dev_key= &key;
    dev_den= &den;
    int length1=800;

    // seed random number generator
    srand(GetTickCount());
    buf = (int*)malloc(worksize);
    for ( i = 0; i < length; i++ ) {
        buf [i] = rand ( )%length1;
    }

    // Fetch the Platform and Device IDs; we only want one.
    error=clGetPlatformIDs(1, &platform, &platforms);
    if (error != CL_SUCCESS) {
            printf("\n Error number %d", error);
    }
    error=clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, 1, &device, &devices);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    //calculating e and d
    //printf("\nENTER FIRST PRIME NUMBER\n");
    //scanf("%ld",&p);
    p = 59;
    flag=prime(p);
    if(flag==0) {
        printf("\nWRONG INPUT\n");
        exit(1);
    }
    //printf("\nENTER ANOTHER PRIME NUMBER\n");
    //scanf("%ld",&q);
    q = 83;
    flag=prime(q);
    if(flag==0||p==q) {
        printf("\nWRONG INPUT\n");
        exit(1);
    }
    //fflush(stdin);
    n=p*q;
    t=(p-1)*(q-1); // t = phi(n)

    ce();

    //printf("\nPOSSIBLE VALUES OF e AND d AND n ARE\n");
    for(i = 0; i < (j - 1); i++) {
        //printf("\n%ld\t%ld \t%d",e[i],d[i],(int)n);
        key = e[i];
        den = d[i];
    }

    // ENTER KEY VALUE
    //printf("\nEnter key parameter e from above set of values 1:");
    //scanf("%d",dev_key);
    //Should this be key parameter n from set of values 3,
    // or key parameter d from set of values 2?
    //Looks like parameter d makes more sense.
    //printf("\nEnter key parameter n from above set of values 2:");
    //scanf("%d",dev_den);


    //clock_gettime(CLOCK_MONOTONIC, &start);/* mark start time */


    // CREATE CONTEXT
    cl_context context=clCreateContext(0, 1, &device, NULL, NULL, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    //CREATE COMMAND QUEUE
    cl_command_queue cq = clCreateCommandQueue(context, device, 0, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    /*//CREATE FILE
    fflush(stdout);
    FILE *fil=fopen("/data/local/tmp/rsa.cl","r");
    if (fil == NULL) {
    	printf("Error, could not open the kernel.");
        fclose(fil);
        return -1;
    }*/

    //CREATE FILE
    fflush(stdout);
    FILE *fil;
    fil = fopen("/sdcard/RSA/rsa.cl", "r");
    char *src;
    src = (char *)malloc(MAX_SOURCE_SIZE);
    srcsize=fread(src, 1, MAX_SOURCE_SIZE, fil);
    fclose(fil);
    const char *srcptr[]={src};

    // Submit the source code of the example kernel to OpenCL
    cl_program prog=clCreateProgramWithSource(context, 1, srcptr, &srcsize, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    // and compile it (after this we could extract the compiled version)
    error=clBuildProgram(prog, 1, &device, NULL, NULL, NULL);
    if ( error != CL_SUCCESS ) {
        printf( "Error on buildProgram " );
        printf("\n Error number %d", error);
        fprintf( stdout, "\nRequestingInfo\n" );
        clGetProgramBuildInfo( prog, device, CL_PROGRAM_BUILD_LOG, 4096, build_c, NULL );
        printf( "Build Log for %s_program:\n%s\n", "example",build_c );
    }

    // Allocate memory for the kernel to work with
    cl_mem mem1, mem2, mem3,mem4;
    mem1=clCreateBuffer(context, CL_MEM_READ_WRITE, worksize, NULL, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    mem2=clCreateBuffer(context, CL_MEM_READ_WRITE, worksize, NULL, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    mem3=clCreateBuffer(context,  CL_MEM_READ_WRITE, worksize, NULL, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    mem4=clCreateBuffer(context,  CL_MEM_READ_WRITE, worksize, NULL, &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    // get a handle and map parameters for the kernel
    cl_kernel k_example=clCreateKernel(prog, "RSA", &error);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error = clSetKernelArg(k_example, 0, sizeof(mem1), &mem1);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error = clSetKernelArg(k_example, 1, sizeof(mem2), &mem2);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error = clSetKernelArg(k_example, 2, sizeof(mem3), &mem3);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error = clSetKernelArg(k_example, 3, sizeof(mem4), &mem4);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    // Target buffer just so we show we got the data from OpenCL
    int buf2[262144];

    // Send input data to OpenCL (async, don't alter the buffer!)
    error=clEnqueueWriteBuffer(cq, mem1, CL_FALSE, 0, worksize, buf, 0, NULL, NULL);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error=clEnqueueWriteBuffer(cq, mem2, CL_FALSE, 0, worksize, dev_key, 0, NULL, NULL);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }
    error=clEnqueueWriteBuffer(cq, mem3, CL_FALSE, 0, worksize, dev_den, 0, NULL, NULL);
    if (error != CL_SUCCESS) {
        printf("\n Error number %d", error);
    }

    // Perform the operation
    const size_t global_worksize=length;


    int timesCompleted;
    fil = fopen("/sdcard/RSA/clMainOutput.txt", "w");
    for(timesCompleted = 0; timesCompleted < numberOfTimes; timesCompleted++) {
		clock_gettime(CLOCK_MONOTONIC, &start);/* mark start time */

		error=clEnqueueNDRangeKernel(cq, k_example, 1, NULL, &global_worksize, NULL, 0, NULL, NULL);
		if (error != CL_SUCCESS) {
			printf("\n Error number %d", error);
		}

		// Read the result back into buf2
		error=clEnqueueReadBuffer(cq, mem4, CL_FALSE, 0, worksize, buf2, 0, NULL, NULL);
		if (error != CL_SUCCESS) {
			printf("\n Error number %d", error);
		}

		// Await completion of all the above
		error=clFinish(cq);
		if (error != CL_SUCCESS) {
			printf("\n Error number %d", error);
		}

		// STOP CLOCK
		clock_gettime(CLOCK_MONOTONIC, &end);/* mark the end time */


		diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;
		//printf("\nElapsed time = %llu nanoseconds\n", (long long unsigned int) diff);
		fprintf(fil, "Elapsed time = %llu nanoseconds\n", (long long unsigned int) diff);
    }
    fclose(fil);

    //I'm not happy with either of these measurements for time yet, I'll be adding in
    // usage of clProfilingInfo

}





















































